/*!
  Highlight.js v11.9.0 (git: f47103d4f1)
  (c) 2006-2023 undefined and other contributors
  License: BSD-3-Clause
 */
var hljs = function () {
    "use strict"; function e(n) {
        return n instanceof Map ? n.clear = n.delete = n.set = () => {
            throw Error("map is read-only")
        } : n instanceof Set && (n.add = n.clear = n.delete = () => {
            throw Error("set is read-only")
        }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((t => {
            const a = n[t], i = typeof a; "object" !== i && "function" !== i || Object.isFrozen(a) || e(a)
        })), n
    } class n {
        constructor(e) {
            void 0 === e.data && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1
        }
        ignoreMatch() { this.isMatchIgnored = !0 }
    } function t(e) {
        return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
    } function a(e, ...n) {
        const t = Object.create(null); for (const n in e) t[n] = e[n]
            ; return n.forEach((e => { for (const n in e) t[n] = e[n] })), t
    } const i = e => !!e.scope
        ; class r {
            constructor(e, n) {
                this.buffer = "", this.classPrefix = n.classPrefix, e.walk(this)
            } addText(e) {
                this.buffer += t(e)
            } openNode(e) {
                if (!i(e)) return; const n = ((e, { prefix: n }) => {
                    if (e.startsWith("language:")) return e.replace("language:", "language-")
                        ; if (e.includes(".")) {
                            const t = e.split(".")
                            ; return [`${n}${t.shift()}`, ...t.map(((e, n) => `${e}${"_".repeat(n + 1)}`))].join(" ")
                        } return `${n}${e}`
                })(e.scope, { prefix: this.classPrefix }); this.span(n)
            }
        closeNode(e) { i(e) && (this.buffer += "</span>") } value() { return this.buffer } span(e) {
            this.buffer += `<span class="${e}">`
        }
    } const s = (e = {}) => {
        const n = { children: [] }
        ; return Object.assign(n, e), n
    }; class o {
        constructor() {
            this.rootNode = s(), this.stack = [this.rootNode]
        } get top() {
            return this.stack[this.stack.length - 1]
        } get root() { return this.rootNode } add(e) {
            this.top.children.push(e)
        } openNode(e) {
            const n = s({ scope: e })
            ; this.add(n), this.stack.push(n)
        } closeNode() {
            if (this.stack.length > 1) return this.stack.pop()
        } closeAllNodes() {
            for (; this.closeNode(););
        } toJSON() { return JSON.stringify(this.rootNode, null, 4) }
        walk(e) { return this.constructor._walk(e, this.rootNode) } static _walk(e, n) {
            return "string" == typeof n ? e.addText(n) : n.children && (e.openNode(n),
                n.children.forEach((n => this._walk(e, n))), e.closeNode(n)), e
        } static _collapse(e) {
            "string" != typeof e && e.children && (e.children.every((e => "string" == typeof e)) ? e.children = [e.children.join("")] : e.children.forEach((e => {
                o._collapse(e)
            })))
        }
    } class l extends o {
        constructor(e) { super(), this.options = e }
        addText(e) { "" !== e && this.add(e) } startScope(e) { this.openNode(e) } endScope() {
            this.closeNode()
        } __addSublanguage(e, n) {
            const t = e.root
            ; n && (t.scope = "language:" + n), this.add(t)
        } toHTML() {
            return new r(this, this.options).value()
        } finalize() {
            return this.closeAllNodes(), !0
        }
    } function c(e) {
        return e ? "string" == typeof e ? e : e.source : null
    } function d(e) { return b("(?=", e, ")") }
    function g(e) { return b("(?:", e, ")*") } function u(e) { return b("(?:", e, ")?") }
    function b(...e) { return e.map((e => c(e))).join("") } function m(...e) {
        const n = (e => {
            const n = e[e.length - 1]
                ; return "object" == typeof n && n.constructor === Object ? (e.splice(e.length - 1, 1), n) : {}
        })(e); return "(" + ((n.capture ? "" : "?:") + e.map((e => c(e))).join("|")) + ")"
    }
    function p(e) { return RegExp(e.toString() + "|").exec("").length - 1 }
    const _ = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
        ; function h(e, { joinWith: n }) {
            let t = 0; return e.map((e => {
                t += 1; const n = t
                    ; let a = c(e), i = ""; for (; a.length > 0;) {
                        const e = _.exec(a); if (!e) { i += a; break }
                        i += a.substring(0, e.index),
                            a = a.substring(e.index + e[0].length), "\\" === e[0][0] && e[1] ? i += "\\" + (Number(e[1]) + n) : (i += e[0],
                                "(" === e[0] && t++)
                    } return i
            })).map((e => `(${e})`)).join(n)
        }
    const f = "[a-zA-Z]\\w*", E = "[a-zA-Z_]\\w*", y = "\\b\\d+(\\.\\d+)?", N = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", w = "\\b(0b[01]+)", v = {
        begin: "\\\\[\\s\\S]", relevance: 0
    }, O = {
        scope: "string", begin: "'", end: "'",
        illegal: "\\n", contains: [v]
    }, k = {
        scope: "string", begin: '"', end: '"', illegal: "\\n",
        contains: [v]
    }, x = (e, n, t = {}) => {
        const i = a({
            scope: "comment", begin: e, end: n,
            contains: []
        }, t); i.contains.push({
            scope: "doctag",
            begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
            end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0
        })
            ; const r = m("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/)
            ; return i.contains.push({ begin: b(/[ ]+/, "(", r, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), i
    }, M = x("//", "$"), S = x("/\\*", "\\*/"), A = x("#", "$"); var C = Object.freeze({
        __proto__: null, APOS_STRING_MODE: O, BACKSLASH_ESCAPE: v, BINARY_NUMBER_MODE: {
            scope: "number", begin: w, relevance: 0
        }, BINARY_NUMBER_RE: w, COMMENT: x,
        C_BLOCK_COMMENT_MODE: S, C_LINE_COMMENT_MODE: M, C_NUMBER_MODE: {
            scope: "number",
            begin: N, relevance: 0
        }, C_NUMBER_RE: N, END_SAME_AS_BEGIN: e => Object.assign(e, {
            "on:begin": (e, n) => { n.data._beginMatch = e[1] }, "on:end": (e, n) => {
                n.data._beginMatch !== e[1] && n.ignoreMatch()
            }
        }), HASH_COMMENT_MODE: A, IDENT_RE: f,
        MATCH_NOTHING_RE: /\b\B/, METHOD_GUARD: { begin: "\\.\\s*" + E, relevance: 0 },
        NUMBER_MODE: { scope: "number", begin: y, relevance: 0 }, NUMBER_RE: y,
        PHRASAL_WORDS_MODE: {
            begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
        }, QUOTE_STRING_MODE: k, REGEXP_MODE: {
            scope: "regexp", begin: /\/(?=[^/\n]*\/)/,
            end: /\/[gimuy]*/, contains: [v, { begin: /\[/, end: /\]/, relevance: 0, contains: [v] }]
        },
        RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
        SHEBANG: (e = {}) => {
            const n = /^#![ ]*\//
            ; return e.binary && (e.begin = b(n, /.*\b/, e.binary, /\b.*/)), a({
                scope: "meta", begin: n,
                end: /$/, relevance: 0, "on:begin": (e, n) => { 0 !== e.index && n.ignoreMatch() }
            }, e)
        },
        TITLE_MODE: { scope: "title", begin: f, relevance: 0 }, UNDERSCORE_IDENT_RE: E,
        UNDERSCORE_TITLE_MODE: { scope: "title", begin: E, relevance: 0 }
    }); function T(e, n) {
        "." === e.input[e.index - 1] && n.ignoreMatch()
    } function R(e, n) {
        void 0 !== e.className && (e.scope = e.className, delete e.className)
    } function D(e, n) {
        n && e.beginKeywords && (e.begin = "\\b(" + e.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)",
            e.__beforeBegin = T, e.keywords = e.keywords || e.beginKeywords, delete e.beginKeywords,
            void 0 === e.relevance && (e.relevance = 0))
    } function I(e, n) {
        Array.isArray(e.illegal) && (e.illegal = m(...e.illegal))
    } function L(e, n) {
        if (e.match) {
            if (e.begin || e.end) throw Error("begin & end are not supported with match")
                ; e.begin = e.match, delete e.match
        }
    } function B(e, n) {
        void 0 === e.relevance && (e.relevance = 1)
    } const $ = (e, n) => {
        if (!e.beforeMatch) return
            ; if (e.starts) throw Error("beforeMatch cannot be used with starts")
                ; const t = Object.assign({}, e); Object.keys(e).forEach((n => {
                    delete e[n]
                })), e.keywords = t.keywords, e.begin = b(t.beforeMatch, d(t.begin)), e.starts = {
                    relevance: 0, contains: [Object.assign(t, { endsParent: !0 })]
                }, e.relevance = 0, delete t.beforeMatch
    }, z = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], F = "keyword"
        ; function U(e, n, t = F) {
            const a = Object.create(null)
            ; return "string" == typeof e ? i(t, e.split(" ")) : Array.isArray(e) ? i(t, e) : Object.keys(e).forEach((t => {
                Object.assign(a, U(e[t], n, t))
            })), a; function i(e, t) {
                n && (t = t.map((e => e.toLowerCase()))), t.forEach((n => {
                    const t = n.split("|")
                    ; a[t[0]] = [e, j(t[0], t[1])]
                }))
            }
        } function j(e, n) {
            return n ? Number(n) : (e => z.includes(e.toLowerCase()))(e) ? 0 : 1
        } const P = {}, K = e => {
            console.error(e)
        }, H = (e, ...n) => { console.log("WARN: " + e, ...n) }, q = (e, n) => {
            P[`${e}/${n}`] || (console.log(`Deprecated as of ${e}. ${n}`), P[`${e}/${n}`] = !0)
        }, G = Error(); function Z(e, n, { key: t }) {
            let a = 0; const i = e[t], r = {}, s = {}
                ; for (let e = 1; e <= n.length; e++)s[e + a] = i[e], r[e + a] = !0, a += p(n[e - 1])
                    ; e[t] = s, e[t]._emit = r, e[t]._multi = !0
        } function W(e) {
            (e => {
                e.scope && "object" == typeof e.scope && null !== e.scope && (e.beginScope = e.scope,
                    delete e.scope)
            })(e), "string" == typeof e.beginScope && (e.beginScope = {
                _wrap: e.beginScope
            }), "string" == typeof e.endScope && (e.endScope = {
                _wrap: e.endScope
            }), (e => {
                if (Array.isArray(e.begin)) {
                    if (e.skip || e.excludeBegin || e.returnBegin) throw K("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),
                        G
                        ; if ("object" != typeof e.beginScope || null === e.beginScope) throw K("beginScope must be object"),
                            G; Z(e, e.begin, { key: "beginScope" }), e.begin = h(e.begin, { joinWith: "" })
                }
            })(e), (e => {
                if (Array.isArray(e.end)) {
                    if (e.skip || e.excludeEnd || e.returnEnd) throw K("skip, excludeEnd, returnEnd not compatible with endScope: {}"),
                        G
                        ; if ("object" != typeof e.endScope || null === e.endScope) throw K("endScope must be object"),
                            G; Z(e, e.end, { key: "endScope" }), e.end = h(e.end, { joinWith: "" })
                }
            })(e)
        } function Q(e) {
            function n(n, t) {
                return RegExp(c(n), "m" + (e.case_insensitive ? "i" : "") + (e.unicodeRegex ? "u" : "") + (t ? "g" : ""))
            } class t {
                constructor() {
                    this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0
                }
                addRule(e, n) {
                    n.position = this.position++, this.matchIndexes[this.matchAt] = n, this.regexes.push([n, e]),
                        this.matchAt += p(e) + 1
                } compile() {
                    0 === this.regexes.length && (this.exec = () => null)
                    ; const e = this.regexes.map((e => e[1])); this.matcherRe = n(h(e, {
                        joinWith: "|"
                    }), !0), this.lastIndex = 0
                } exec(e) {
                    this.matcherRe.lastIndex = this.lastIndex
                    ; const n = this.matcherRe.exec(e); if (!n) return null
                        ; const t = n.findIndex(((e, n) => n > 0 && void 0 !== e)), a = this.matchIndexes[t]
                        ; return n.splice(0, t), Object.assign(n, a)
                }
            } class i {
                constructor() {
                    this.rules = [], this.multiRegexes = [],
                        this.count = 0, this.lastIndex = 0, this.regexIndex = 0
                } getMatcher(e) {
                    if (this.multiRegexes[e]) return this.multiRegexes[e]; const n = new t
                        ; return this.rules.slice(e).forEach((([e, t]) => n.addRule(e, t))),
                            n.compile(), this.multiRegexes[e] = n, n
                } resumingScanAtSamePosition() {
                    return 0 !== this.regexIndex
                } considerAll() { this.regexIndex = 0 } addRule(e, n) {
                    this.rules.push([e, n]), "begin" === n.type && this.count++
                } exec(e) {
                    const n = this.getMatcher(this.regexIndex); n.lastIndex = this.lastIndex
                        ; let t = n.exec(e)
                        ; if (this.resumingScanAtSamePosition()) if (t && t.index === this.lastIndex); else {
                            const n = this.getMatcher(0); n.lastIndex = this.lastIndex + 1, t = n.exec(e)
                        }
                    return t && (this.regexIndex += t.position + 1,
                        this.regexIndex === this.count && this.considerAll()), t
                }
            }
            if (e.compilerExtensions || (e.compilerExtensions = []),
                e.contains && e.contains.includes("self")) throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.")
                ; return e.classNameAliases = a(e.classNameAliases || {}), function t(r, s) {
                    const o = r
                    ; if (r.isCompiled) return o
                        ;[R, L, W, $].forEach((e => e(r, s))), e.compilerExtensions.forEach((e => e(r, s))),
                            r.__beforeBegin = null, [D, I, B].forEach((e => e(r, s))), r.isCompiled = !0; let l = null
                        ; return "object" == typeof r.keywords && r.keywords.$pattern && (r.keywords = Object.assign({}, r.keywords),
                            l = r.keywords.$pattern,
                            delete r.keywords.$pattern), l = l || /\w+/, r.keywords && (r.keywords = U(r.keywords, e.case_insensitive)),
                            o.keywordPatternRe = n(l, !0),
                            s && (r.begin || (r.begin = /\B|\b/), o.beginRe = n(o.begin), r.end || r.endsWithParent || (r.end = /\B|\b/),
                                r.end && (o.endRe = n(o.end)),
                                o.terminatorEnd = c(o.end) || "", r.endsWithParent && s.terminatorEnd && (o.terminatorEnd += (r.end ? "|" : "") + s.terminatorEnd)),
                            r.illegal && (o.illegalRe = n(r.illegal)),
                            r.contains || (r.contains = []), r.contains = [].concat(...r.contains.map((e => (e => (e.variants && !e.cachedVariants && (e.cachedVariants = e.variants.map((n => a(e, {
                                variants: null
                            }, n)))), e.cachedVariants ? e.cachedVariants : X(e) ? a(e, {
                                starts: e.starts ? a(e.starts) : null
                            }) : Object.isFrozen(e) ? a(e) : e))("self" === e ? r : e)))), r.contains.forEach((e => {
                                t(e, o)
                            })), r.starts && t(r.starts, s), o.matcher = (e => {
                                const n = new i
                                ; return e.contains.forEach((e => n.addRule(e.begin, {
                                    rule: e, type: "begin"
                                }))), e.terminatorEnd && n.addRule(e.terminatorEnd, {
                                    type: "end"
                                }), e.illegal && n.addRule(e.illegal, { type: "illegal" }), n
                            })(o), o
                }(e)
        } function X(e) {
            return !!e && (e.endsWithParent || X(e.starts))
        } class V extends Error {
        constructor(e, n) { super(e), this.name = "HTMLInjectionError", this.html = n }
    }
    const J = t, Y = a, ee = Symbol("nomatch"), ne = t => {
        const a = Object.create(null), i = Object.create(null), r = []; let s = !0
            ; const o = "Could not find the language '{}', did you forget to load/include a language module?", c = {
                disableAutodetect: !0, name: "Plain text", contains: []
            }; let p = {
                ignoreUnescapedHTML: !1, throwUnescapedHTML: !1, noHighlightRe: /^(no-?highlight)$/i,
                languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-",
                cssSelector: "pre code", languages: null, __emitter: l
            }; function _(e) {
                return p.noHighlightRe.test(e)
            } function h(e, n, t) {
                let a = "", i = ""
                ; "object" == typeof n ? (a = e,
                    t = n.ignoreIllegals, i = n.language) : (q("10.7.0", "highlight(lang, code, ...args) has been deprecated."),
                        q("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),
                        i = e, a = n), void 0 === t && (t = !0); const r = { code: a, language: i }; x("before:highlight", r)
                    ; const s = r.result ? r.result : f(r.language, r.code, t)
                    ; return s.code = r.code, x("after:highlight", s), s
            } function f(e, t, i, r) {
                const l = Object.create(null); function c() {
                    if (!x.keywords) return void S.addText(A)
                        ; let e = 0; x.keywordPatternRe.lastIndex = 0; let n = x.keywordPatternRe.exec(A), t = ""
                        ; for (; n;) {
                            t += A.substring(e, n.index)
                            ; const i = w.case_insensitive ? n[0].toLowerCase() : n[0], r = (a = i, x.keywords[a]); if (r) {
                                const [e, a] = r
                                    ; if (S.addText(t), t = "", l[i] = (l[i] || 0) + 1, l[i] <= 7 && (C += a), e.startsWith("_")) t += n[0]; else {
                                        const t = w.classNameAliases[e] || e; g(n[0], t)
                                    }
                            } else t += n[0]
                                ; e = x.keywordPatternRe.lastIndex, n = x.keywordPatternRe.exec(A)
                        } var a
                        ; t += A.substring(e), S.addText(t)
                } function d() {
                    null != x.subLanguage ? (() => {
                        if ("" === A) return; let e = null; if ("string" == typeof x.subLanguage) {
                            if (!a[x.subLanguage]) return void S.addText(A)
                                ; e = f(x.subLanguage, A, !0, M[x.subLanguage]), M[x.subLanguage] = e._top
                        } else e = E(A, x.subLanguage.length ? x.subLanguage : null)
                            ; x.relevance > 0 && (C += e.relevance), S.__addSublanguage(e._emitter, e.language)
                    })() : c(), A = ""
                } function g(e, n) {
                    "" !== e && (S.startScope(n), S.addText(e), S.endScope())
                } function u(e, n) {
                    let t = 1
                    ; const a = n.length - 1; for (; t <= a;) {
                        if (!e._emit[t]) { t++; continue }
                        const a = w.classNameAliases[e[t]] || e[t], i = n[t]; a ? g(i, a) : (A = i, c(), A = ""), t++
                    }
                }
                function b(e, n) {
                    return e.scope && "string" == typeof e.scope && S.openNode(w.classNameAliases[e.scope] || e.scope),
                        e.beginScope && (e.beginScope._wrap ? (g(A, w.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap),
                            A = "") : e.beginScope._multi && (u(e.beginScope, n), A = "")), x = Object.create(e, {
                                parent: {
                                    value: x
                                }
                            }), x
                } function m(e, t, a) {
                    let i = ((e, n) => {
                        const t = e && e.exec(n)
                        ; return t && 0 === t.index
                    })(e.endRe, a); if (i) {
                        if (e["on:end"]) {
                            const a = new n(e)
                            ; e["on:end"](t, a), a.isMatchIgnored && (i = !1)
                        } if (i) {
                            for (; e.endsParent && e.parent;)e = e.parent; return e
                        }
                    }
                    if (e.endsWithParent) return m(e.parent, t, a)
                } function _(e) {
                    return 0 === x.matcher.regexIndex ? (A += e[0], 1) : (D = !0, 0)
                } function h(e) {
                    const n = e[0], a = t.substring(e.index), i = m(x, e, a); if (!i) return ee; const r = x
                        ; x.endScope && x.endScope._wrap ? (d(),
                            g(n, x.endScope._wrap)) : x.endScope && x.endScope._multi ? (d(),
                                u(x.endScope, e)) : r.skip ? A += n : (r.returnEnd || r.excludeEnd || (A += n),
                                    d(), r.excludeEnd && (A = n)); do {
                                        x.scope && S.closeNode(), x.skip || x.subLanguage || (C += x.relevance), x = x.parent
                                    } while (x !== i.parent); return i.starts && b(i.starts, e), r.returnEnd ? 0 : n.length
                }
                let y = {}; function N(a, r) {
                    const o = r && r[0]; if (A += a, null == o) return d(), 0
                        ; if ("begin" === y.type && "end" === r.type && y.index === r.index && "" === o) {
                            if (A += t.slice(r.index, r.index + 1), !s) {
                                const n = Error(`0 width match regex (${e})`)
                                ; throw n.languageName = e, n.badRule = y.rule, n
                            } return 1
                        }
                    if (y = r, "begin" === r.type) return (e => {
                        const t = e[0], a = e.rule, i = new n(a), r = [a.__beforeBegin, a["on:begin"]]
                            ; for (const n of r) if (n && (n(e, i), i.isMatchIgnored)) return _(t)
                                ; return a.skip ? A += t : (a.excludeBegin && (A += t),
                                    d(), a.returnBegin || a.excludeBegin || (A = t)), b(a, e), a.returnBegin ? 0 : t.length
                    })(r)
                        ; if ("illegal" === r.type && !i) {
                            const e = Error('Illegal lexeme "' + o + '" for mode ' + (x.scope || "<unnamed>"))
                                ; throw e.mode = x, e
                        } if ("end" === r.type) { const e = h(r); if (e !== ee) return e }
                    if ("illegal" === r.type && "" === o) return 1
                        ; if (R > 1e5 && R > 3 * r.index) throw Error("potential infinite loop, way more iterations than matches")
                            ; return A += o, o.length
                } const w = v(e)
                    ; if (!w) throw K(o.replace("{}", e)), Error('Unknown language: "' + e + '"')
                        ; const O = Q(w); let k = "", x = r || O; const M = {}, S = new p.__emitter(p); (() => {
                            const e = []
                            ; for (let n = x; n !== w; n = n.parent)n.scope && e.unshift(n.scope)
                                ; e.forEach((e => S.openNode(e)))
                        })(); let A = "", C = 0, T = 0, R = 0, D = !1; try {
                            if (w.__emitTokens) w.__emitTokens(t, S); else {
                                for (x.matcher.considerAll(); ;) {
                                    R++, D ? D = !1 : x.matcher.considerAll(), x.matcher.lastIndex = T
                                        ; const e = x.matcher.exec(t); if (!e) break; const n = N(t.substring(T, e.index), e)
                                        ; T = e.index + n
                                } N(t.substring(T))
                            } return S.finalize(), k = S.toHTML(), {
                                language: e,
                                value: k, relevance: C, illegal: !1, _emitter: S, _top: x
                            }
                        } catch (n) {
                            if (n.message && n.message.includes("Illegal")) return {
                                language: e, value: J(t),
                                illegal: !0, relevance: 0, _illegalBy: {
                                    message: n.message, index: T,
                                    context: t.slice(T - 100, T + 100), mode: n.mode, resultSoFar: k
                                }, _emitter: S
                            }; if (s) return {
                                language: e, value: J(t), illegal: !1, relevance: 0, errorRaised: n, _emitter: S, _top: x
                            }
                                ; throw n
                        }
            } function E(e, n) {
                n = n || p.languages || Object.keys(a); const t = (e => {
                    const n = { value: J(e), illegal: !1, relevance: 0, _top: c, _emitter: new p.__emitter(p) }
                        ; return n._emitter.addText(e), n
                })(e), i = n.filter(v).filter(k).map((n => f(n, e, !1)))
                    ; i.unshift(t); const r = i.sort(((e, n) => {
                        if (e.relevance !== n.relevance) return n.relevance - e.relevance
                            ; if (e.language && n.language) {
                                if (v(e.language).supersetOf === n.language) return 1
                                    ; if (v(n.language).supersetOf === e.language) return -1
                            } return 0
                    })), [s, o] = r, l = s
                    ; return l.secondBest = o, l
            } function y(e) {
                let n = null; const t = (e => {
                    let n = e.className + " "; n += e.parentNode ? e.parentNode.className : ""
                        ; const t = p.languageDetectRe.exec(n); if (t) {
                            const n = v(t[1])
                            ; return n || (H(o.replace("{}", t[1])),
                                H("Falling back to no-highlight mode for this block.", e)), n ? t[1] : "no-highlight"
                        }
                    return n.split(/\s+/).find((e => _(e) || v(e)))
                })(e); if (_(t)) return
                    ; if (x("before:highlightElement", {
                        el: e, language: t
                    }), e.dataset.highlighted) return void console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", e)
                        ; if (e.children.length > 0 && (p.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),
                            console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
                            console.warn("The element with unescaped HTML:"),
                            console.warn(e)), p.throwUnescapedHTML)) throw new V("One of your code blocks includes unescaped HTML.", e.innerHTML)
                    ; n = e; const a = n.textContent, r = t ? h(a, { language: t, ignoreIllegals: !0 }) : E(a)
                    ; e.innerHTML = r.value, e.dataset.highlighted = "yes", ((e, n, t) => {
                        const a = n && i[n] || t
                        ; e.classList.add("hljs"), e.classList.add("language-" + a)
                    })(e, t, r.language), e.result = {
                        language: r.language, re: r.relevance,
                        relevance: r.relevance
                    }, r.secondBest && (e.secondBest = {
                        language: r.secondBest.language, relevance: r.secondBest.relevance
                    }), x("after:highlightElement", { el: e, result: r, text: a })
            } let N = !1; function w() {
                "loading" !== document.readyState ? document.querySelectorAll(p.cssSelector).forEach(y) : N = !0
            } function v(e) { return e = (e || "").toLowerCase(), a[e] || a[i[e]] }
        function O(e, { languageName: n }) {
            "string" == typeof e && (e = [e]), e.forEach((e => {
                i[e.toLowerCase()] = n
            }))
        } function k(e) {
            const n = v(e)
            ; return n && !n.disableAutodetect
        } function x(e, n) {
            const t = e; r.forEach((e => {
                e[t] && e[t](n)
            }))
        }
        "undefined" != typeof window && window.addEventListener && window.addEventListener("DOMContentLoaded", (() => {
            N && w()
        }), !1), Object.assign(t, {
            highlight: h, highlightAuto: E, highlightAll: w,
            highlightElement: y,
            highlightBlock: e => (q("10.7.0", "highlightBlock will be removed entirely in v12.0"),
                q("10.7.0", "Please use highlightElement now."), y(e)), configure: e => { p = Y(p, e) },
            initHighlighting: () => {
                w(), q("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.")
            },
            initHighlightingOnLoad: () => {
                w(), q("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
            }, registerLanguage: (e, n) => {
                let i = null; try { i = n(t) } catch (n) {
                    if (K("Language definition for '{}' could not be registered.".replace("{}", e)),
                        !s) throw n; K(n), i = c
                }
                i.name || (i.name = e), a[e] = i, i.rawDefinition = n.bind(null, t), i.aliases && O(i.aliases, {
                    languageName: e
                })
            }, unregisterLanguage: e => {
                delete a[e]
                ; for (const n of Object.keys(i)) i[n] === e && delete i[n]
            },
            listLanguages: () => Object.keys(a), getLanguage: v, registerAliases: O,
            autoDetection: k, inherit: Y, addPlugin: e => {
                (e => {
                    e["before:highlightBlock"] && !e["before:highlightElement"] && (e["before:highlightElement"] = n => {
                        e["before:highlightBlock"](Object.assign({ block: n.el }, n))
                    }), e["after:highlightBlock"] && !e["after:highlightElement"] && (e["after:highlightElement"] = n => {
                        e["after:highlightBlock"](Object.assign({ block: n.el }, n))
                    })
                })(e), r.push(e)
            },
            removePlugin: e => { const n = r.indexOf(e); -1 !== n && r.splice(n, 1) }
        }), t.debugMode = () => {
            s = !1
        }, t.safeMode = () => { s = !0 }, t.versionString = "11.9.0", t.regex = {
            concat: b,
            lookahead: d, either: m, optional: u, anyNumberOfTimes: g
        }
            ; for (const n in C) "object" == typeof C[n] && e(C[n]); return Object.assign(t, C), t
    }, te = ne({}); te.newInstance = () => ne({}); var ae = te; const ie = e => ({
        IMPORTANT: {
            scope: "meta", begin: "!important"
        }, BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE, HEXCOLOR: {
            scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
        },
        FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
            scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$",
            contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE]
        }, CSS_NUMBER_MODE: {
            scope: "number",
            begin: e.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
            relevance: 0
        }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ }, BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE
    }), re = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], se = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"], oe = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"], le = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"], ce = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "inline-size", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse(), de = oe.concat(le)
        ; var ge = "[0-9](_*[0-9])*", ue = `\\.(${ge})`, be = "[0-9a-fA-F](_*[0-9a-fA-F])*", me = {
            className: "number", variants: [{
                begin: `(\\b(${ge})((${ue})|\\.)?|(${ue}))[eE][+-]?(${ge})[fFdD]?\\b`
            }, {
                begin: `\\b(${ge})((${ue})[fFdD]?\\b|\\.([fFdD]\\b)?)`
            }, {
                begin: `(${ue})[fFdD]?\\b`
            }, { begin: `\\b(${ge})[fFdD]\\b` }, {
                begin: `\\b0[xX]((${be})\\.?|(${be})?\\.(${be}))[pP][+-]?(${ge})[fFdD]?\\b`
            }, {
                begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b"
            }, { begin: `\\b0[xX](${be})[lL]?\\b` }, {
                begin: "\\b0(_*[0-7])*[lL]?\\b"
            }, { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }],
            relevance: 0
        }; function pe(e, n, t) { return -1 === t ? "" : e.replace(n, (a => pe(e, n, t - 1))) }
    const _e = "[A-Za-z$_][0-9A-Za-z$_]*", he = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], fe = ["true", "false", "null", "undefined", "NaN", "Infinity"], Ee = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], ye = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], Ne = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], we = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"], ve = [].concat(Ne, Ee, ye)
        ; function Oe(e) {
            const n = e.regex, t = _e, a = {
                begin: /<[A-Za-z0-9\\._:-]+/,
                end: /\/[A-Za-z0-9\\._:-]+>|\/>/, isTrulyOpeningTag: (e, n) => {
                    const t = e[0].length + e.index, a = e.input[t]
                        ; if ("<" === a || "," === a) return void n.ignoreMatch(); let i
                        ; ">" === a && (((e, { after: n }) => {
                            const t = "</" + e[0].slice(1)
                            ; return -1 !== e.input.indexOf(t, n)
                        })(e, { after: t }) || n.ignoreMatch())
                        ; const r = e.input.substring(t)
                        ; ((i = r.match(/^\s*=/)) || (i = r.match(/^\s+extends\s+/)) && 0 === i.index) && n.ignoreMatch()
                }
            }, i = {
                $pattern: _e, keyword: he, literal: fe, built_in: ve, "variable.language": we
            }, r = "[0-9](_?[0-9])*", s = `\\.(${r})`, o = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", l = {
                className: "number", variants: [{
                    begin: `(\\b(${o})((${s})|\\.)?|(${s}))[eE][+-]?(${r})\\b`
                }, {
                    begin: `\\b(${o})\\b((${s})\\b|\\.)?|(${s})\\b`
                }, {
                    begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
                }, {
                    begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
                }, {
                    begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
                }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, {
                    begin: "\\b0[0-7]+n?\\b"
                }], relevance: 0
            }, c = {
                className: "subst", begin: "\\$\\{",
                end: "\\}", keywords: i, contains: []
            }, d = {
                begin: "html`", end: "", starts: {
                    end: "`",
                    returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "xml"
                }
            }, g = {
                begin: "css`", end: "", starts: {
                    end: "`", returnEnd: !1,
                    contains: [e.BACKSLASH_ESCAPE, c], subLanguage: "css"
                }
            }, u = {
                begin: "gql`", end: "",
                starts: {
                    end: "`", returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, c],
                    subLanguage: "graphql"
                }
            }, b = {
                className: "string", begin: "`", end: "`",
                contains: [e.BACKSLASH_ESCAPE, c]
            }, m = {
                className: "comment",
                variants: [e.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
                    relevance: 0, contains: [{
                        begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [{
                            className: "doctag",
                            begin: "@[A-Za-z]+"
                        }, {
                            className: "type", begin: "\\{", end: "\\}", excludeEnd: !0,
                            excludeBegin: !0, relevance: 0
                        }, {
                            className: "variable", begin: t + "(?=\\s*(-)|$)",
                            endsParent: !0, relevance: 0
                        }, { begin: /(?=[^\n])\s/, relevance: 0 }]
                    }]
                }), e.C_BLOCK_COMMENT_MODE, e.C_LINE_COMMENT_MODE]
            }, p = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, d, g, u, b, { match: /\$\d+/ }, l]
            ; c.contains = p.concat({
                begin: /\{/, end: /\}/, keywords: i, contains: ["self"].concat(p)
            }); const _ = [].concat(m, c.contains), h = _.concat([{
                begin: /\(/, end: /\)/, keywords: i,
                contains: ["self"].concat(_)
            }]), f = {
                className: "params", begin: /\(/, end: /\)/,
                excludeBegin: !0, excludeEnd: !0, keywords: i, contains: h
            }, E = {
                variants: [{
                    match: [/class/, /\s+/, t, /\s+/, /extends/, /\s+/, n.concat(t, "(", n.concat(/\./, t), ")*")],
                    scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" }
                }, {
                    match: [/class/, /\s+/, t], scope: { 1: "keyword", 3: "title.class" }
                }]
            }, y = {
                relevance: 0,
                match: n.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
                className: "title.class", keywords: { _: [...Ee, ...ye] }
            }, N = {
                variants: [{
                    match: [/function/, /\s+/, t, /(?=\s*\()/]
                }, { match: [/function/, /\s*(?=\()/] }],
                className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [f],
                illegal: /%/
            }, w = {
                match: n.concat(/\b/, (v = [...Ne, "super", "import"], n.concat("(?!", v.join("|"), ")")), t, n.lookahead(/\(/)),
                className: "title.function", relevance: 0
            }; var v; const O = {
                begin: n.concat(/\./, n.lookahead(n.concat(t, /(?![0-9A-Za-z$_(])/))), end: t,
                excludeBegin: !0, keywords: "prototype", className: "property", relevance: 0
            }, k = {
                match: [/get|set/, /\s+/, t, /(?=\()/], className: { 1: "keyword", 3: "title.function" },
                contains: [{ begin: /\(\)/ }, f]
            }, x = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e.UNDERSCORE_IDENT_RE + ")\\s*=>", M = {
                match: [/const|var|let/, /\s+/, t, /\s*/, /=\s*/, /(async\s*)?/, n.lookahead(x)],
                keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [f]
            }
                ; return {
                    name: "JavaScript", aliases: ["js", "jsx", "mjs", "cjs"], keywords: i, exports: {
                        PARAMS_CONTAINS: h, CLASS_REFERENCE: y
                    }, illegal: /#(?![$_A-z])/,
                    contains: [e.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), {
                        label: "use_strict", className: "meta", relevance: 10,
                        begin: /^\s*['"]use (strict|asm)['"]/
                    }, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, d, g, u, b, m, { match: /\$\d+/ }, l, y, {
                        className: "attr", begin: t + n.lookahead(":"), relevance: 0
                    }, M, {
                        begin: "(" + e.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
                        keywords: "return throw case", relevance: 0, contains: [m, e.REGEXP_MODE, {
                            className: "function", begin: x, returnBegin: !0, end: "\\s*=>", contains: [{
                                className: "params", variants: [{ begin: e.UNDERSCORE_IDENT_RE, relevance: 0 }, {
                                    className: null, begin: /\(\s*\)/, skip: !0
                                }, {
                                    begin: /\(/, end: /\)/, excludeBegin: !0,
                                    excludeEnd: !0, keywords: i, contains: h
                                }]
                            }]
                        }, { begin: /,/, relevance: 0 }, {
                            match: /\s+/,
                                relevance: 0
                            }, {
                                variants: [{ begin: "<>", end: "</>" }, {
                                    match: /<[A-Za-z0-9\._:-]+\s*\/>/
                                }, {
                                    begin: a.begin,
                                    "on:begin": a.isTrulyOpeningTag, end: a.end
                                }], subLanguage: "xml", contains: [{
                                    begin: a.begin, end: a.end, skip: !0, contains: ["self"]
                                }]
                            }]
                    }, N, {
                        beginKeywords: "while if switch catch for"
                    }, {
                        begin: "\\b(?!function)" + e.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
                        returnBegin: !0, label: "func.def", contains: [f, e.inherit(e.TITLE_MODE, {
                            begin: t,
                            className: "title.function"
                        })]
                    }, { match: /\.\.\./, relevance: 0 }, O, {
                        match: "\\$" + t,
                        relevance: 0
                    }, {
                        match: [/\\bconstructor(?=\s*\()/], className: { 1: "title.function" },
                        contains: [f]
                    }, w, {
                        relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/,
                        className: "variable.constant"
                    }, E, k, { match: /\$[(.]/ }]
                }
        }
    const Ke = {
        grmr_stata: e => {
            const n = {
                keyword: \"abbrev abs acos acosh adoupdate anova append args as asin asinh assert atan atan2 atanh autocode bar betaden binomial binomialp binomialtail binormalbofd bootstrap box break browse br byteorder by bysort bys c capture cap cast cauchy cauchyden cauchytail cd Cdhms ceil char chi2 chi2den chi2tail Chms cholesky chop clear clip clock Clock cloglog Cmdyhms codebook cofC Cofc cofd Cofd coleqnumb collatorlocale collatorversion colnfreeparms colnumb colsof collapse comb compress cond continue contract copy corr cos cosh count daily datasignature datasig date day det describe des dgammapda dgammapdada dgammapdadx dgammapdx dgammapdxdx dhms diag diag0cnt digamma dir discard display di distinct dofb dofc dofC dofh dofm dofq dofw dofy dow doy doedit do drop duplicates dups dunnettprob e edit else el end epsdouble epsfloat erase ereturn eret estimates est exit expand expandcl exp exponential exponentialden exponentialtail export F Fden fileexists fileread filereaderror filewrite file fillin findit float floor fmtwidth foreach forvalues format fp Ftail gammaden gammap gammaptail generate gen get global glo graph hadamard halfyear halfyearly help hh hhC hms hist hofd hours hypergeometric hypergeometricp I ibeta ibetatail if igaussian igaussianden igaussiantail import indexnot infix inlist inrange insheet inspect int inv invbinomial invbinomialtail invcauchy invcauchytail invchi2 invchi2tail invcloglog invdunnettprob invexponential invexponentialtail invF invFtail invgammap invgammaptail invibeta invibetatail invigaussian invigaussiantail invlaplace invlaplacetail invlogistic invlogistictail invlogit invnbinomial invnbinomialtail invnchi2 invnchi2tail invnF invnFtail invnibeta invnormal invnt invnttail invpoisson invpoissontail invsym invt invttail invtukeyprob invweibull invweibullph invweibullphtail invweibulltail irecode issymmetric itrim J java jdk jdbc joinby keep label lab labelbook labelanguage laplace laplaceden laplacetail length line list ln lncauchyden lnfactorial lngamma lnigammaden lnigaussianden lniwishartden lnlaplaceden lnmvnormalden lnnormal lnnormalden lnwishartden local loc log log10 logistic logisticden logistictail logit lower ls ltrim macro matmissing matuniform matrix mat mata max maxbyte maxdouble maxfloat maxint maxlong mdy mdyhms merge mfp mi min minbyte mindouble minfloat minint minlong minutes missing mkdir mm mmC mod mofd month monthly more move mreldif msofhours msofminutes msofseconds nbetaden nbinomial nbinomialp nbinomialtail nchi2 nchi2den nchi2tail nestreg net nF nFden nFtail nibeta noisily noi normal normalden notes npnchi2 npnF npnt nt ntden nttail nullmat odbc order outsheet pause permute plural poisson poissonp poissontail postfile post postclose predict program define proper probit python qofd quarter quarterly quietly qui r rbeta rbinomial rcauchy rchi2 real recode recast regexs reldif rename ren replace replay reshape return ret reverse rexponential rgamma rhypergeometric rigaussian rlaplace rlogistic rmdir rnbinomial rnormal rolling round roweqnumb rownfreeparms rownumb rowsof rpoisson rt rtrim runiform runiformint run rweibull rweibullph s save scalar scatter search seconds separate set sign simulate sin sinh sleep smallestdouble sort soundex sqrt sreturn sret ss ssC ssc stack statsby stepwise string stritrim strlen strlower strltrim strmatch strofreal strpos strproper strreverse strrpos strrtrim strtoname strtrim strupper subinstr subinword substr sum summarize summarise svy sweep sysuse t tabulate tab tab1 tab2 table tan tanh tc tC td tden tempvar tempname tempfile test th tin tm tobytes tokenize tq trace trigamma trim trunc ttail tukeyprob twoway tw twithin type uchar udstrlen udsubstr uisdigit uisletter update upper use ustrcompare ustrcompareex ustrfix ustrfrom ustrinvalidcnt ustrleft ustrlen ustrlower ustrltrim ustrnormalize ustrpos ustrregexs ustrreverse ustrright ustrrpos ustrrtrim ustrsortkey ustrsortkeyex ustrtitle ustrto ustrtohex ustrtoname ustrtrim ustrunescape ustrupper ustrword ustrwordcount usubinstr usubstr vec vecdiag version webuse week weekly weibull weibullden weibullph weibullphden weibullphtail weibulltail while wofd word wordbreaklocale wordcount xi xmlsave xmluse xpose year yearly yh ym yofd yq yw\",
literal: \"null missing\",built_in:\"_all _n _N\"},t=[e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE,{className:\"string\",\nbegin:/`\"/,end:/\"'/},{className:\"string\",begin:/\"/,end:/\"/},{className:\"variable\",\nvariants:[{begin:/\\$\\w+/},{begin:/\\$\\{\\w+\\}/},{begin:/`\\w+'/}]},{className:\"number\",\nvariants:[{begin:\"\\\\b\\\\d+(\\\\.?\\\\d+)?\\\\b\"},{begin:\"\\\\.\\\\d+\\\\b\"}]},{className:\"meta\",\nbegin:\"^\\\\s*\\\\.\\\\s+\"}];return{name:\"Stata\",aliases:[\"do\",\"ado\"],keywords:n,\ncontains:t}}
}; const He = ae; for (const e of Object.keys(Ke)) {
                const n = e.replace("grmr_", "").replace("_", "-"); He.registerLanguage(n, Ke[e])
            }
            return He
        }()
        ; "object" == typeof exports && "undefined" != typeof module && (module.exports = hljs);
